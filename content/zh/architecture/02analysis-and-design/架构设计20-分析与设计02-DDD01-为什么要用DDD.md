[架构设计](https://www.jianshu.com/c/753debf1423d)系列文章，请参见连接。

从开发过程中的实际问题出发，给出这些问题在DDD中的解决方式以及引申意义。以方法论的方式将这些整理出来，可以将方法借用到其他地方，并不需要完整的使用DDD。

> 如果你要构建的软件系统没有什么业务复杂度，领域驱动设计就发挥不了它的价值；如果构建软件的团队对于软件复杂度控制漠不关心，只顾着追赶进度而采取“头疼医头，脚疼医脚”的态度，领域驱动设计这套方法可能入不了他们的法眼。-《解构领域驱动设计》2.4 冷静认知

# 0. 背景
## 0.1 秩序
如果没有遇到过类似于复杂问题，并自己想过办法去处理复杂问题在代码层面的呈现。没有遇到并处理过这类问题时，则本文中所阐述的问题对于你来说没有意义。
从无序中建立秩序，在别人未意识到的领域内，建立规则。
1. 根本没人能看懂你在做什么
2. 建立起来的规则，需要传播给其他人去追随

- **规模**
就比如自家装修和建设城市的区别：管网设计，道路设计，基础设施设计都有根本上的不一致。

所以，就需要先跟读者说清楚DDD的背后思维逻辑是什么，才可真正的接受并解决问题。

## 0.2 架构
> 从更大的范围来说，术语“架构”总是意味着“不变的深层次结构”--Stewart Brand, 《How Buildings Learn》 

> 我们希望你现在已经理解，如果你的系统要满足其品质要求，架构决定是很重要的，你需要注意架构，有意识地做出这些决定，而不只是“让架构自动出现”。--《架构之美》

控制复杂度

有意识的去管理过程

## 0.3 没有银弹
人月神话

## 0.4 发现问题、分析问题、解决问题
[正确定义问题，比解决问题重要一百倍](https://www.woshipm.com/pmd/1660198.html)


学习DDD要先了解它解决了那个问题域中的问题，解决方案是什么样的。

# 1.认知级别

## 1.1 软件认知的七级别
在架构设计与实现过程中，需要对软件系统做全局的分析与考虑以求全局的认知。在分析和考虑过程中软件的不同层次都有独特的问题。为了在设计阶段做出更全面的决策，以解决绝大部分实现过程中可能遇到的问题，需要对软件开发过程中不同的层次的工作内容进行具体的分析。

所以需要对软件设计与决策提供全局框架，并把握每个层次的关键点。

![软件层次](https://upload-images.jianshu.io/upload_images/2454595-dac30c1d90583ee5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540)

理解清楚你所使用的解决方案在哪个层次，并解决了哪些问题。哪些问题是未被意识到的，未被解决的。战略设计  与  战术设计在不同的层次中完成。架构设计不可能能用一张图或者一个文档描述清楚所有的内容。

- **模块层面**
archunit：处理的是依赖关系，即实体、服务的边界的定义

- **代码层面**
sonar，p3c，PMD，jacoco，lint等。都可以进行代码级别的扫描，是代码一级的保证方式。iPlasma主要用来检测上帝类

## 1.2 从无序中建立秩序
分不清，用不清的设计模式

## 1.3 内卷：低层次/质量竞争
只知道代码层面的内容，只会代码层面的内容。不知道代码层面之上还有6个级别。那么大家就只能在代码层面上进行竞争了。

## 1.4 知道技术细节并不意味着可以用在自己的代码中。
例如在Redis中使用布隆过滤时使用的是那种数据结构存储bitmap的？

## 1.5 有没有被问过读过开源项目代码
他们的问的到底是什么？那是问你知不知道细节，另外问的是有没有理解面向对象？

# 1.6 反模式
> 适度耦合--《演进式架构》

冗余字段，冗余表，横切表，纵切表

# 1.7 解决复杂问题的方法
- **抽象**
- **分解**
- **知识**



# 2. DDD的场景
## 2.1 应对复杂问题

### 2.1.1 消除不确定性

### 2.1.2 边界的定义

### 2.1.3 规模、结构、变化

## 2.2 战略与战术设计

### 2.2.1 统一语言、子域、限界上下文映射

### 2.2.2 实体，聚合，聚合根，值对象

### 2.2.3 EA：业务架构，应用架构，技术架构，数据架构

## 2.3 大泥球

### 2.3.1 形成过程

### 2.3.2 服务群和服务层

## 2.4 设计模式
微服务可以在几个方面使云基础设施受益。首先，它们允许对应用程序的各个部分进行更细化地控制，云中的应用程序可以轻松地进行部署和管理。


### 2.4.1《重构》
从代码层面的优化内容与现在动辄几十万行代码的项目来说，有点捉襟见肘了。

### 2.4.2 老服务代码架构堪称灾难，整体遵守“想到哪就写到哪，需要啥就拷贝啥”的设计原则，完全不考虑单一职责、接口隔离、最少知识、模块化、封装复用等。


## 2.5 分包方式
### 2.5.1 mvc以及其变形的问题

变种

### 2.5.2 上帝类

上帝类是所有东西都写在一个类中。

# 3. 不适合使用DDD的场景
哈哈哈。并不是万能的。没有银弹。没必要复杂化。

## 3.1 事务脚本
## 3.2 算法与数据结构型
## 3.3 性能场景

# 4. DDD弊端

DDD中不好的，并不是不能说。

## 4.1 没有参与的领域专家

# 5. 总结

# 6. 参考
[祖传代码重构——从25万行到5万行](https://km.woa.com/group/51889/articles/show/528928)
[如何管理云原生应用程序的依赖关系](https://www.infoq.cn/article/1TvgZix4z6HlMubu061X)
